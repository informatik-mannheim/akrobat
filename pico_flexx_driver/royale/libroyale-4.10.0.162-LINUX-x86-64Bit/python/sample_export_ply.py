#!/usr/bin/python3

# Copyright (C) 2017 Infineon Technologies & pmdtechnologies ag
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
# PARTICULAR PURPOSE.

"""This sample shows how to export an rrf file in PLY format
"""

import argparse
import roypy
import time
import queue
import sys
from sample_camera_info import print_camera_info
from roypy_sample_utils import CameraOpener, add_camera_opener_options
from roypy_platform_utils import PlatformHelper

import numpy as np
import matplotlib.pyplot as plt

class MyListener(roypy.IDepthDataListener):
    def __init__(self, frameToExport, output):
        super(MyListener, self).__init__()
        self.f = open(output,"w+")
        self.frame = 0
        self.frameToExport = frameToExport
        self.done = False

    def onNewData(self, data):
        numPoints = data.getNumPoints()

        # ply header
        self.f.write('ply\n')
        self.f.write('format ascii 1.0\n')
        self.f.write('comment Generated by the sample_export_ply.py script '+ roypy.getVersionString()+'\n')
        self.f.write('element vertex '+str(numPoints)+'\n')
        self.f.write('property float x\n')
        self.f.write('property float y\n')
        self.f.write('property float z\n')
        self.f.write('property uchar red\n')
        self.f.write('property uchar green\n')
        self.f.write('property uchar blue\n')
        self.f.write('element face 0\n')
        self.f.write('property list uchar int vertex_index\n')
        self.f.write('end_header\n')

        # Find out the absolute of the amplitude difference
        minAmp = 65535
        maxAmp = 0

        for i in range(numPoints):
            if(data.getDepthConfidence(i) > 0):
                if(data.getGrayValue(i) < minAmp):
                    minAmp = data.getGrayValue(i)
                elif(data.getGrayValue(i) > maxAmp):
                    maxAmp = data.getGrayValue(i)
           
        rangeDiff = maxAmp - minAmp

        # We don't want to divide by zero if we have no amplitude difference
        if rangeDiff == 0:
            rangeDiff = 1
        for i in range(numPoints):
            pixelColor = 0
            if data.getDepthConfidence(i) > 0:
                # Color the points in the point cloud according to the amplitude
                pixelColor = ((data.getGrayValue(i) - minAmp) / rangeDiff) * 255.0
                
            # round and remove trailing zeroes
            xString = str(round(data.getX(i),6))
            xString = xString.rstrip('0').rstrip('.')

            yString = str(round(data.getY(i),6))
            yString = yString.rstrip('0').rstrip('.')

            zString = str(round(data.getZ(i),5))
            zString = zString.rstrip('0').rstrip('.')

            self.f.write(xString+" "+yString+" "+zString+" ")
                
            # Make sure the color is rgb (0-255)
            pixelColor = int(pixelColor)
            self.f.write(str(pixelColor)+" "+str(pixelColor)+" "+str(pixelColor)+"\n")

        self.done = True


def main ():
    # Set the available arguments
    platformhelper = PlatformHelper()
    parser = argparse.ArgumentParser (usage = __doc__)
    add_camera_opener_options (parser)
    parser.add_argument ("--frame", type=int, default = 0, help="frame to be converted into PLY")
    parser.add_argument ("--output", type=str, default = "output.ply", help="name of the output file")
    options = parser.parse_args()
   
    opener = CameraOpener (options)

    frameToExport = options.frame

    try:
        cam = opener.open_camera ()
    except:
        print("could not open Camera Interface")
        sys.exit(1)

    print("Export filename: "+options.output)
    print("Frame to export: "+str(frameToExport))

    # retrieve the interface that is available for recordings
    replay = cam.asReplay()
    print ("Framecount : ", replay.frameCount())
    print ("File version : ", replay.getFileVersion())

    # make sure the recording is sending the data on maximum speed and doesn't repeat
    replay.useTimestamps(False)
    replay.loop(False)
    # set the right frame to be read next
    replay.seek(frameToExport)

    l = MyListener(frameToExport,options.output)

    cam.registerDataListener(l)
    cam.startCapture()

    # wait for onNewData to be called
    while l.done==False:
        time.sleep(0.5)
    cam.stopCapture()
    print("Done")

def process_event_queue (q, writer, replay):

    while True:
        try:
            # try to retrieve an item from the queue.
            # this will block until an item can be retrieved
            # or the timeout of 1 second is hit
            if len(q.queue) == 0:
                item = q.get(True, 1)
            else:
                for i in range (0, len (q.queue)):
                    item = q.get(True, 1)
        except queue.Empty:
            # this will be thrown when the timeout is hit
            break
        else:
            print(str(replay.currentFrame()))
            writer.write(item)

if (__name__ == "__main__"):
    main()
